InnoDB事务的隔离级别有四级，默认是“可重复读”（REPEATABLE READ）。   
  1.  未提交读（READ UNCOMMITTED）。另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）。
  2.  提交读（READ COMMITTED）。本事务读取到的是最新的数据（其他事务提交后的）。问题是，在同一个事务里，前后两次相同的SELECT会读到不同的结果（不重复读）。
  3.  可重复读（REPEATABLE READ）。在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象（稍后解释）。
  4.  串行化（SERIALIZABLE）。读操作会隐式获取共享锁，可以保证不同事务间的互斥。  
  
四个级别逐渐增强，每个级别解决一个问题。  
  1.  脏读，最容易理解。另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据。
  2.  不重复读。解决了脏读后，会遇到，同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致。
  3.  幻读。解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会“惊奇的”发现了这些新数据，貌似之前读到的数据是“鬼影”一样的幻觉。


当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的next-key locks可以避免幻读。 
next-key locks需要应用程序自己去加锁。   
MySQL InnoDB的可重复读并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是next-key locks。但是next-key locks会使普通读加锁。   
重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。

[原文](https://mp.weixin.qq.com/s?__biz=MzIzMzgxOTQ5NA==&mid=2247496794&idx=2&sn=9608df29393fdccb0b25da75ac522813&chksm=e8fd6853df8ae1454122ffc89647622ad6cd2ce1386ac968f469864a602b18865428b97540cf&mpshare=1&scene=1&srcid=0706ixdAd9048gZfpgO9NZFt&sharer_sharetime=1593999127493&sharer_shareid=7fccbb6e38b69cfc35054be7928be058&key=7b0bb172d3b89960799e5ce5aa1a4d56b61bc86ca54d095931136eaadb1ec49f499dc92aede45e4a4f69df64c1201cb683219d3c0f544628c64aea4f586bb53c1cfb32467688420b8d8b2e85993a4a8a&ascene=1&uin=MjUwNzEwMTIyMg%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=AfUPsO9dkg5jJi1w7Q0YSUA%3D&pass_ticket=bFnrkf%2F1jWK6o5TPAIfH6luXazVjOx4kzGbZTx23qyMXR%2B7n5T3HO8M068l5iCdV)

事务MVCC（多版本并发控制）  ：  
多版本并发控制，其实指的是一条记录会有多个版本，每次修改记录都会存储这条记录被修改之前的版本，多版本之间串联起来就形成了一条版本链。
这样不同时刻启动的事务可以无锁地获得不同版本的数据(普通读)。此时读(普通读)写操作不会阻塞，写操作可以继续写，无非就是多加了一个版本，
历史版本记录可供已经启动的事务读取。  

主要是为了实现读已提交和可重复读。首先隔离级别如果是读未提交的话，直接读最新版本的数据就行了，压根就不需要保存以前的版本。可串行化隔离级
别事务都串行执行了，所以也不需要多版本，因此 MVCC 是用来实现读已提交和可重复读的。    
实际上 InnoDB 不会真的存储了多个版本的数据，只是借助 undolog 记录每次写操作的反向操作，所以索引上对应的记录只会有一个版本，即最新版本。
只不过可以根据 undolog 中的记录反向操作得到数据的历史版本，所以看起来是多个版本。  




为什么需要MVCC：
防止读写操作之间得冲突，当两个事务同时操作一条数据时，a读取，b修改，若b未提交，那么a将无法读取最新数据，不然就发生了脏读问题，
只能用锁阻塞等待事务b的提交.  
如果有多版本的话，就不一样了。事务b修改的记录，还未提交，但是记录被修改之前的版本还在，此时事务a就可以读取之前的版本数据
，这样读写之间就不会阻塞啦，所以说 MVCC 提高了事务的并发度，提升数据库的性能。

为什么会产生可重复读和提交读：   
*  每当产生一个新事务，会有一个系统版本号`sys_id`，该id自增。
*  在InnoDB中，聚簇索引记录中包含两个隐藏列：  
    1. trx_id：对记录进行改动时，trx_id会记录当前事务id，也就是当前系统版本号；
    2. roll_pointer：对记录进行改动，会把旧版本记录写入undolog，roll_pointer指向修改之前的版本；
    3. 对同一条记录的更新，会把旧值放到一条undo日志中，作为一个旧版本的记录，多次更新之后这些版本会被roll_pointer连接成一个链表，称之为版本链。
*   版本链读取：  
    对于读取已提交和可重复读，就会用到版本链，判断版本链中哪个版本对当前事务可见；
    此时，MySQL就会使用ReadView（快照），ReadView存放了含当前**已经开始但是没有提交的事务**的列表，记录每个事务的事务id，记最小事务id为min_id，
    最大事务id为max_id；   
     *   版本比较规则：
         1.  如果当前trx_id小于min_id，说明这个记录版本是已经被提交过的，对其他事务可见；
         2.  如果当前trx_id大于max_id，说明这个记录版本是ReadView生成之后发生的，不能访问；
         3.  如果记录版本的trx_id在min_id和max_id之间，判断trx_id是否在ReadView中：
                *  如果在ReadView中，说明事务还未提交，该记录版本不可访问；
                *  如果不在ReadView中，说明该事务已经提交，该记录版本可以访问；

    如果当前记录版本不可读，就根据回滚指针roll_pointer找到旧版本的记录再进行判断； .
    对于读取已提交，每次查询都会生成一个新的ReadView；  
    对于可重复度，一个事务在第一次SELECT的时候生成一个ReadView，之后的查询复用这个ReadView；  

     
    