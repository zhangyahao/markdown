# SQL 窗口函数详解

## 一、窗口函数概述

窗口函数（Window Function）是对一组行进行计算，并为**每一行**返回一个值的函数。与聚合函数不同，窗口函数不减少行数，而是保留所有行并添加计算结果作为新列。

### 基本语法结构

```sql
<窗口函数> OVER (
    [PARTITION BY <列名>]
    [ORDER BY <列名> [ASC|DESC]]
    [ROWS|RANGE <窗口框架>]
)
```

## 二、主要窗口函数分类

### 1. 排名函数

#### ROW_NUMBER() - 行号

```sql
SELECT employee_id,
       department_id,
       salary,
       ROW_NUMBER() OVER (ORDER BY salary DESC) as row_num
FROM employees;

-- 按部门分组排名
SELECT employee_id,
       department_id,
       salary,
       ROW_NUMBER() OVER (
           PARTITION BY department_id
           ORDER BY salary DESC
           ) as dept_rank
FROM employees;
```

#### RANK() - 排名（允许并列）

```sql
-- 相同值排名相同，下一个排名跳过相应位置
SELECT student_id,
       score,
       RANK() OVER (ORDER BY score DESC) as rank
FROM exam_results;
-- 分数：100, 100, 90, 85 → 排名：1, 1, 3, 4
```

#### DENSE_RANK() - 密集排名

```sql
-- 相同值排名相同，但下一个排名不跳过
SELECT student_id,
       score,
       DENSE_RANK() OVER (ORDER BY score DESC) as dense_rank
FROM exam_results;
-- 分数：100, 100, 90, 85 → 排名：1, 1, 2, 3
```

#### NTILE(n) - 分桶函数

```sql
-- 将数据分为n组，并分配组号
SELECT employee_id,
       salary,
       NTILE(4) OVER (ORDER BY salary) as quartile
FROM employees;
```

### 2. 聚合窗口函数

#### 基本用法

```sql
SELECT order_date,
       product_id,
       revenue,
       -- 累计收入
       SUM(revenue) OVER (
           ORDER BY order_date
           )                                as cumulative_revenue,

       -- 按产品累计收入
       SUM(revenue) OVER (
           PARTITION BY product_id
           ORDER BY order_date
           )                                as product_cumulative,

       -- 移动平均（近3天）
       AVG(revenue) OVER (
           ORDER BY order_date
           ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
           )                                as moving_avg_3days,

       -- 占总额比例
       revenue / SUM(revenue) OVER () * 100 as percent_of_total
FROM sales;
```

### 3. 前后值函数

#### LEAD() 和 LAG() - 获取前后行的值

```sql
SELECT date,
       revenue,
       -- 前一天的收入
       LAG(revenue, 1) OVER (ORDER BY date)               as prev_day_revenue,

       -- 后一天的收入
       LEAD(revenue, 1) OVER (ORDER BY date)              as next_day_revenue,

       -- 计算日环比
       revenue / LAG(revenue, 1) OVER (ORDER BY date) - 1 as daily_growth_rate
FROM daily_sales;
```

#### FIRST_VALUE() 和 LAST_VALUE() - 获取首尾值

```sql
SELECT employee_id,
       department_id,
       salary,
       hire_date,
       -- 部门最高工资
       FIRST_VALUE(salary) OVER (
           PARTITION BY department_id
           ORDER BY salary DESC
           ) as highest_salary_in_dept,

       -- 部门最低工资
       FIRST_VALUE(salary) OVER (
           PARTITION BY department_id
           ORDER BY salary ASC
           ) as lowest_salary_in_dept
FROM employees;
```

### 4. 统计函数

#### 百分比排名

```sql
SELECT student_id,
       score,
       PERCENT_RANK() OVER (ORDER BY score) as percent_rank
FROM exam_results;
-- 返回0-1之间的值，表示相对排名位置
```

#### 累计分布

```sql
SELECT salary,
       CUME_DIST() OVER (ORDER BY salary) as cumulative_distribution
FROM employees;
-- 返回值小于等于当前值的行数比例
```

## 三、窗口框架子句

### ROWS 与 RANGE 的区别

```sql
-- ROWS: 基于物理行数
SELECT date,
       revenue,
       SUM(revenue) OVER (
           ORDER BY date
           ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING
           ) as sum_around
FROM sales;

-- RANGE: 基于逻辑值范围
SELECT date,
       revenue,
       SUM(revenue) OVER (
           ORDER BY date
           RANGE BETWEEN INTERVAL '2' DAY PRECEDING AND CURRENT ROW
           ) as sum_3days
FROM sales;
```

### 常用窗口框架

```sql
-- 从开始到当前行
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW

-- 整个分区
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING

-- 当前行前后各一行
ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING

-- 当前行之前的3行到当前行
ROWS BETWEEN 3 PRECEDING AND CURRENT ROW
```

## 四、高级应用示例

### 1. 计算移动平均和标准差

```sql
SELECT date,
       revenue,
       AVG(revenue) OVER (
           ORDER BY date
           ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
           ) as moving_avg_7days,

       STDDEV(revenue) OVER (
           ORDER BY date
           ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
           ) as moving_stddev_7days
FROM daily_sales;
```

### 2. 分组内Top-N查询

```sql
-- 查询每个部门工资前三的员工
WITH ranked_employees AS (SELECT employee_id,
                                 department_id,
                                 salary,
                                 ROW_NUMBER() OVER (
                                     PARTITION BY department_id
                                     ORDER BY salary DESC
                                     ) as rank_in_dept
                          FROM employees)
SELECT *
FROM ranked_employees
WHERE rank_in_dept <= 3;
```

### 3. 计算累计百分比

```sql
SELECT product_id,
       revenue,
       SUM(revenue) OVER (ORDER BY revenue DESC) as cumulative_sum,
       SUM(revenue) OVER ()                      as total_revenue,
       SUM(revenue) OVER (ORDER BY revenue DESC) * 100.0 /
       SUM(revenue) OVER ()                      as cumulative_percent
FROM product_sales;
```

### 4. 数据对比分析

```sql
SELECT month,
       category,
       sales,
       -- 与上个月比较
       LAG(sales, 1) OVER (
           PARTITION BY category
           ORDER BY month
           ) as prev_month_sales,

       -- 与去年同期比较
       LAG(sales, 12) OVER (
           PARTITION BY category
           ORDER BY month
           ) as year_ago_sales,

       -- 类别内排名
       RANK() OVER (
           PARTITION BY month
           ORDER BY sales DESC
           ) as category_rank
FROM monthly_category_sales;
```

## 五、性能优化建议

### 1. 使用索引优化

```sql

-- 为窗口函数的PARTITION BY和ORDER BY列创建索引
CREATE INDEX idx_dept_salary ON employees (department_id, salary DESC);

-- 复合索引对以下查询有益
SELECT employee_id,
       department_id,
       salary,
       RANK() OVER (PARTITION BY department_id ORDER BY salary DESC)
FROM employees;
```

### 2. 避免全表扫描

```sql
-- 不好的写法：全表排序
SELECT *, ROW_NUMBER() OVER (ORDER BY id)
FROM large_table;

-- 好的写法：限制范围
WITH limited AS (SELECT *
                 FROM large_table
                 WHERE created_at >= '2024-01-01')
SELECT *, ROW_NUMBER() OVER (ORDER BY id)
FROM limited;
```

### 3. 使用CTE提高可读性和性能

```sql
WITH sales_agg AS (SELECT product_id,
                          date_trunc('month', order_date) as month,
                          SUM(amount)                     as monthly_sales
                   FROM orders
                   GROUP BY 1, 2),
     monthly_analysis AS (SELECT *,
                                 LAG(monthly_sales) OVER (
                                     PARTITION BY product_id
                                     ORDER BY month
                                     ) as prev_month_sales
                          FROM sales_agg)
SELECT *,
       monthly_sales - prev_month_sales as month_over_month_change
FROM monthly_analysis;
```

## 六、各数据库差异

| 函数特性        | PostgreSQL | MySQL 8.0+ | SQL Server | Oracle |
|:------------|:-----------|:-----------|:-----------|:-------|
| 窗口函数支持      | 完整支持       | 完整支持       | 完整支持       | 完整支持   |
| RANGE支持时间间隔 | 支持         | 有限支持       | 支持         | 支持     |
| 命名窗口        | 支持         | 支持         | 支持         | 支持     |
| QUALIFY子句   | 不支持        | 不支持        | 不支持        | 支持     |

### 命名窗口示例（多个函数共享同一窗口定义）



```sql
SELECT 
    employee_id,
    department_id,
    salary,
    ROW_NUMBER() OVER w as row_num,
    RANK() OVER w as rank_num,
    SUM(salary) OVER w as dept_total
FROM employees
WINDOW w AS (
    PARTITION BY department_id
    ORDER BY salary DESC
    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
);
```

窗口函数是SQL中非常强大的功能，能够解决复杂的数据分析问题，同时保持查询的高效性。掌握窗口函数可以显著提高数据处理的效率和灵活性。