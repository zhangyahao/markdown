1.   redis的并发竞争  
     Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在  
     Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：
        1.  客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。
        2.  服务器角度，利用setnx实现锁。注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也
            可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。会造成死锁.
2.   redis的缓存失效策略和主键失效机制  
        * 影响生存时间的一些操作  
           生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆盖原来的数据，
        * redis 提供 6种数据淘汰策略  
           *  volatile-lru： 从已设置过期时间的数据集（ server.db\[i\].expires）中挑选最近最少使用的数据淘汰  
           *  volatile-random： 从已设置过期时间的数据集（ server.db\[i\].expires）中任意选择数据淘汰
           *  volatile-ttl： 从已设置过期时间的数据集（ server.db\[i\].expires）中挑选将要过期的数据淘汰
           *  allkeys-lru： 从数据集（ server.db\[i\].dict）中挑选最近最少使用的数据淘汰
           *  allkeys-random： 从数据集（ server.db\[i\].dict）中任意选择数据淘汰
           *  no-enviction（驱逐）： 禁止驱逐数据 
3.   redis常见性能问题和解决方案  
        *  Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。
        *  Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久
        *   Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。
4.   假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？             
       使用keys指令可以扫出指定模式的key列表。但redis是单线程的，此项操作会导致线程阻塞，影响线上服务。这个时候可以使用scan指令，  
       scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。
5.   如果有大量的key需要设置同一时间过期，一般需要注意什么？     
     如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。
     
     
           