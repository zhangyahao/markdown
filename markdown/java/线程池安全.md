##线程池创建
1. Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。
2. 真正的线程池接口是ExecutorService.`  ExecutorService executorService = Executors.newSingleThreadExecutor();`
        比较重要的几个类<br>
        
| name | 作用|
|:------:|:-----:|
|ExecutorService|真正的线程池接口。|
|ScheduledExecutorService|能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。|
|ThreadPoolExecutor|ExecutorService的默认实现。|
|ScheduledThreadPoolExecutor|继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。|
 
 
3. java通过Executors提供四种线程池，分别为：
    1.  `Executors.newCachedThreadPool()`,创建一个可缓存线程池，缓冲池容量大小为Integer.MAX_VALUE，如果线程池长
            度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
    2.   `Executors.newFixedThreadPool(int)`，创建一个定长的线程池，可控制线程最大并发数，超出的线程会在队列中等待。但要注意：
            ```text
             newFixedThreadPool线程池的核心线程数是固定的，它使用了近乎于无界的LinkedBlockingQueue阻塞队列。当核心线程用完后，  
             任务会入队到阻塞队列，如果任务执行的时间比较长，没有释放，会导致越来越多的任务堆积到阻塞队列，最后导致机器的内存使用不停的飙升，造成JVM OOM。
            ```
    3.   `newScheduledThreadPool`，创建一个定长线程池，支持定时及周期性任务执行。
    4.   `Executors.newSingleThreadExecutor() `， 创建一个单线程化(容量为1)的线程池，它只会用唯一的工作线程来执行任务，
        保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
        
4.  线程池关闭
     1.  `shutdown()`：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务
     2.  `shutdownNow()`：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务 
     3.  以上两个方法都不会等到所有任务完成后关闭，需要通过`awaitTermination(long timeout,, TimeUnit   unit)`方法实现；
            timeout - 最长等待时间   unit - timeout 参数的时间单位
            
