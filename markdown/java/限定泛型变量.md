限定类型可以有多个，使用“&”分隔。比如：
```text
<T super Comparable & Serializable>
```
无论何时定义一个泛型类型，都自动提供了一个相应的原始类型。程序运行时，擦除类型变量，并替换为第一个限定类型（比如被替换为Comparable），
无限定的变量使用Object。
但要注意，如果是数组类型，那么当传入得数据类型是无限定变量，那么他的超类即为object，那么当传入得是该类型得数组，那么它将变为 object[],
那么将能在其中存入任何元素，也就会出现类型错误。  

不能向<? extends Employee >类型的变量调用set方法的。假设它可以执行，因为程序无法知道这个变量的具体类型，它的类型可能是Manager，  
也可能是Executive，那么就会出现类型转换错误。只能向这个变量调用get方法，因为程序把获得的值自动转换为Employee类型，子类型可以自动转换为父类型。  

不能向<? super Employee>类型的变量调用get方法，因为程序无法知道返回的具体类型，它的类型可能是Person，也有可能是Object。只能调用set方法，  
因为不管是传入Employee还是其子类，都可以成功执行。 


总之，带有super限定的通配符可以向泛型对象写入，带有extends限定的通配符可以从泛型对象读取。而`Sanesee`和`Sanesee类型`的不同点在于，
Sanesee类型擦除以后就是Object了，所以根本无法使用Object类型的对象去调用它，只有将它放在静态方法中执行一些简单的操作。


    
