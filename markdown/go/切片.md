1.  ##内部实现
    ```aidl
        切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为机遇数组实现，所以它的底层的
        内存是连续非配的，效率非常高，还可以通过索引获得数据，可以迭代以及垃圾回收优化的好处。
    ```
    切片对象非常小，是因为它是只有3个字段的数据结构：一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量。
    这3个字段，就是Go语言操作底层数组的元数据，有了它们，我们就可以任意的操作切片了。
2. ##声明和初始化    
    创建方式有多种
    ````aidl
       slice:=make([]int,5)
    ````
    使用内置的make函数时，需要传入一个参数，指定切片的长度。当然也可以单独指定切片的容量。
    ```aidl
       slice:=make([]int,5,10)
    ```
    这样创建的切片长度时5，容量时10,需要注意的这个容量10其实对应的是切片底层数组的。<br>
    因为切片的底层是数组，所以创建切片时，如果不指定字面值的话，默认值就是数组的元素的零值。虽然指定了容量是10，
    但是只能访问5个元素，因为切片的长度是5，剩下的5个元素，需要切片扩充后才可以访问。
    ```aidl
       容量必须>=长度，我们是不能创建长度大于容量的切片的。
    ```
    还有一种创建切片的方式，是使用字面量，就是指定初始化的值。
    ```aidl
    slice:=[]int{1,2,3,4,5}
    ```
    切片还有nil切片和空切片，它们的长度和容量都是0，但是它们指向底层数组的指针不一样，
    nil切片意味着指向底层数组的指针为nil，而空切片对应的指针是个地址。
    ````aidl
       //nil切片
       var nilSlice []int
       
       //空切片
       slice:=[]int{}
    ````
    nil切片表示不存在的切片，而空切片表示一个空集合，它们各有用处。<br>
    切片另外一个用处比较多的创建是基于现有的数组或者切片创建。
    ```aidl
       slice := []int{1, 2, 3, 4, 5}
       slice1 := slice[:]
       slice2 := slice[0:]
       slice3 := slice[:5]
       
       fmt.Println(slice1)
       fmt.Println(slice2)
       fmt.Println(slice3)
    ```
    基于现有的切片或者数组创建，使用`[i:j]`这样的操作符即可，她表示以i索引开始，到j索引结束,截取原数组或者切片，
    创建而成的新切片，新切片的值包含原切片的i索引，但是不包含j索引。对比Java的话，发现和String的subString方法很像。<br>
    不论是新的切片还是原始切片，都是公用同一个数组得，当修改时，底层得数组发生改变，那么所有基于这个数组得切片都将受到影响
    ```aidl
       slice := []int{1, 2, 3, 4, 5}
       newSlice := slice[1:2:3]
    ```
    第三个参数表示容量，不过第三个参数不能超过原切片得最大索引
    
3. ##使用切片    
    ```aidl
       切片只能访问到其长度内的元素，访问超过长度外的元素，会导致运行时异常，与切片容量关联的元素只能用于切片增长。
    ```
    理解：切片容量这个参数，用途一般有两个，一个时初始化切片，一个是切片扩容<br>
    切片算是一个动态数组，所以它可以按需增长，使用内置append函数即可。append函数可以为一个切片追加一个元素，
    至于如何增加、返回的是原切片还是一个新切片、长度和容量如何改变这些细节，append函数都会自动处理。
    ```aidl
       slice := []int{1, 2, 3, 4, 5}
       newSlice := slice[1:3]
       
       newSlice=append(newSlice,10)
       fmt.Println(newSlice)
       fmt.Println(slice)
       //Output
       [2 3 10]
       [1 2 3 10 5]
    ```
   如果切片的底层数组，没有足够的容量时，就会新建一个底层数组，把原来数组的值复制到新底层数组里，
   再追加新值，这时候就不会影响原来的底层数组了。
   ```aidl
    所以一般我们在创建新切片的时候，最好要让新切片的长度和容量一样，这样我们在追加操作的时候就会生成新的底层数组，
    和原有数组分离，就不会因为共用底层数组而引起奇怪问题,因为共用数组的时候修改内容，会影响多个切片。
    ```
   ` append`函数会智能的增长底层数组的容量，目前的算法是：容量小于1000个时，总是成倍的增长，一旦容量超过1000个，
    增长因子设为1.25，也就是说每次会增加25%的容量。内置的append也是一个可变参数的函数，所以我们可以同时追加好几个值。
    ```aidl
       newSlice=append(newSlice,10,20,30)
    ```
    此外，还可以通过...操作符，把一个切片追加到另一个切片里。
    ```aidl
       slice := []int{1, 2, 3, 4, 5}
       newSlice := slice[1:2:3]
       
       newSlice=append(newSlice,slice...)
       fmt.Println(newSlice)
       fmt.Println(slice)

    ```
    
    
   
    
    