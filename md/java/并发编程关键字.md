###ThreadLocal、Volatile、synchronized、Atomic这四个关键字
1.  Atomic<br>
    作用<br>
    对于原子性的操作。是一个装饰者。仅限于修饰基本数据类型。
    

2.  Volatile<br>
    作用
    volatile可以看做是一个轻量级的synchronized，它可以在多线程并
    发的情况下保证变量的“可见性”。所谓的可见性就是在线程中修改了
    该变量的值，该值会立即回显到主内存中，从而保证所有的线程看到这个
    变量的值的值。<br>
    详解
    1. 当new出一个变量后，它将保存在内存中，但因为cpu的运行速度非常快，它将将该数据保存一份到自己的高速缓存中<br>
        cpu操作的只是该变量的高速缓存，操作完成后，才会写入内存中。但是因为写操作是一个耗时操作，所以当多线程<br>
        同时操作一个变量的情况下，就会出现数据的不一致性。
    2.  `Volatile`是先写后读，所以只能保证每个线程在使用这个变量时，变量的正确性，但不能保证最终结果，因为它修饰<br>
         的变量并不能保证原子性操纵。
3. synchronized<br>
    作用<br>
    synchronized叫做同步锁
    
    
4. Threadlocal<br>
    作用<br>
    关于ThreadLocal，这个类的出现并不是用来解决在多线程并发环境下资源的共享问题的，
    它和其它三个关键字不一样，其它三个关键字都是从线程外来保证变量的一致性，这样使
    得多个线程访问的变量具有一致性，可以更好的体现出资源的共享。
    这个类中包含一个map对象，将数据存放在map中，数据将和线程绑定。
    
    ###总结
     1、对于synchronized的出现，是解决多线程资源共享的问题，同步机制采用了“以时间换空间”的方式：访问串行化，对象共享化。
         同步机制是提供一份变量，让所有线程都可以访问。
    
     2、对于Atomic的出现，是通过原子操作指令+Lock-Free完成，从而实现非阻塞式的并发问题。
    
     3、对于Volatile，为多线程资源共享问题解决了部分需求，在非依赖自身的操作的情况下，对变量的改变将对任何线程可见。
    
     4、对于ThreadLocal的出现，并不是解决多线程资源共享的问题，而是用来提供线程内的局部变量，省去参数传递这个不必要的麻
     烦，ThreadLocal采用了“以空间换时间”的方式：访问并行化，对象独享化。ThreadLocal是为每一个线程都提供了一份独有的变量，各个线程互不影响。